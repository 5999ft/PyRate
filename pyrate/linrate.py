"""
Pixel-by-pixel linear rate (velocity) estimation using iterative weighted
least-squares method.

Based on original Matlab code by Hua Wang and Juliet Biggs, and Matlab 'lscov'
function.

.. codeauthor: Matt Garthwaite and Sudipta Basak, GA
"""

from scipy.linalg import solve, cholesky, qr, inv
from numpy import nan, isnan, sqrt, diag, delete, ones, array, nonzero, float32
import numpy as np


def is_pos_def(x):
    return np.all(np.linalg.eigvals(x) > 1e-6)


def linear_rate(ifgs, vcm, pthr, nsig, maxsig, mst=None):
    """
    Pixel-by-pixel linear rate (velocity) estimation using iterative weighted least-squares method.

    :param ifgs: Sequence of ifg objs from which to extract observations
    :param vcm: Derived positive definite temporal variance covariance matrix
    :param pthr: Pixel threshold; minimum number of coherent observations for a pixel
    :param nsig: n-sigma ratio used to threshold 'model minus observation' residuals
    :param maxsig: Threshold for maximum allowable standard error
    :param mst: Pixel-wise matrix describing the minimum spanning tree network

    :return:
        python/matlab variable names
        rate/ifg_stack: stacked interferogram (i.e., rate map)
        error/std_stack: standard deviation of the stacked interferogram
                  (i.e., error map)
        samples/coh_sta: statistics of coherent pixels used for stacking
        demerror:  dem errors in metres, no implemented in python
    """

    rows, cols = ifgs[0].phase_data.shape
    nifgs = len(ifgs)

    # make 3D block of observations
    obs = array([np.where(isnan(x.phase_data), 0, x.phase_data) for x in ifgs])
    span = array([[x.time_span for x in ifgs]])

    # Update MST in case additional NaNs generated by APS filtering
    if mst is not None:
        mst[isnan(obs)] = 0
    else:  # dummy mst if none is passed in
        mst = ones((nifgs, rows, cols))

    # preallocate NaN arrays
    # TODO: Q Sudipta: why nans? and not zeros? nans cause issues later on
    # TODO: Investigate impact of this change from matlab
    error = np.zeros([rows, cols], dtype=float32)
    rate = np.zeros([rows, cols], dtype=float32)
    samples = np.zeros([rows, cols], dtype=float32)

    # pixel-by-pixel calculation.
    # nested loops to loop over the 2 image dimensions
    for i in xrange(rows):
        for j in xrange(cols):
            # find the indices of independent ifgs for given pixel from MST
            ind = mst[:, i, j].nonzero()[0]  # only True's in mst are chosen

            # iterative loop to calculate 'robust' velocity for pixel

            while len(ind) >= pthr:
                # make vector of selected ifg observations
                ifgv = obs[ind, i, j]

                # form design matrix from appropriate ifg time spans
                B = span[:, ind]

                # Subset of full VCM matrix for selected observations
                V = vcm[:, ind][ind, :]

                # Get the lower triangle cholesky decomposition. V must be positive definite (symmetrical and square)
                T = cholesky(V, 1)

                # Incorporate inverse of VCM into the design matrix and observations vector
                A = solve(T, B.transpose())
                b = solve(T, ifgv.transpose())

                # Factor the design matrix, incorporate covariances or weights into the
                # system of equations, and transform the response vector.
                Q, R = qr(A, mode='economic')
                z = Q.conj().transpose().dot(b)

                # Compute the Lstsq coefficient for the velocity
                v = solve(R, z)

                # Compute the model errors; added by Hua Wang, 12/12/2011
                err1 = inv(V).dot(B.conj().transpose())
                err2 = B.dot(err1)
                err = sqrt(diag(inv(err2)))

                # Compute the residuals (model minus observations)
                r = (B * v) - ifgv

                # determine the ratio of residuals and apriori variances (Danish method)
                w = cholesky(inv(V))
                wr = abs(w * r.transpose())

                # test if maximum ratio is greater than user threshold.
                maxr = diag(wr).max()
                maxi = nonzero(wr == maxr)[0][0]

                if maxr > nsig:
                    # if yes, discard and re-do the calculation.
                    # TODO: what if len(ind)<pthr and maxr <=nsig?
                    # For example: nsig=3, and pthr=5,
                    # can there be len(ind)= 4 or less, and maxr < 3?
                    # Then rate/error/samples will contain nan for that pixel
                    ind = delete(ind, maxi)
                else:
                    #if no save estimate, exit the while loop and go to next pixel
                    rate[i, j] = v
                    error[i, j] = err
                    samples[i, j] = ifgv.shape[0]
                    break

    # overwrite the data whose error is larger than the maximum sigma user threshold
    rate[error > maxsig] = nan
    error[error > maxsig] = nan
    samples[error > maxsig] = nan

    return rate, error, samples

if __name__ == "__main__":
    import os
    import shutil
    from subprocess import call

    from pyrate.scripts import run_pyrate
    from pyrate import matlab_mst_kruskal as matlab_mst
    from pyrate.tests.common import SYD_TEST_MATLAB_ORBITAL_DIR, SYD_TEST_OUT
    from pyrate import config as cf
    from pyrate import reference_phase_estimation as rpe
    from pyrate import vcm


    # start each full test run cleanly
    shutil.rmtree(SYD_TEST_OUT, ignore_errors=True)

    os.makedirs(SYD_TEST_OUT)

    params = cf.get_config_params(
            os.path.join(SYD_TEST_MATLAB_ORBITAL_DIR, 'orbital_error.conf'))
    params[cf.REF_EST_METHOD] = 2
    call(["python", "pyrate/scripts/run_prepifg.py",
          os.path.join(SYD_TEST_MATLAB_ORBITAL_DIR, 'orbital_error.conf')])

    xlks, ylks, crop = run_pyrate.transform_params(params)

    base_ifg_paths = run_pyrate.original_ifg_paths(params[cf.IFG_FILE_LIST])

    dest_paths = run_pyrate.get_dest_paths(base_ifg_paths, crop, params, xlks)

    ifg_instance = matlab_mst.IfgListPyRate(datafiles=dest_paths)

    assert isinstance(ifg_instance, matlab_mst.IfgListPyRate)
    ifgs = ifg_instance.ifgs
    for i in ifgs:
        if not i.mm_converted:
            i.convert_to_mm()
            i.write_modified_phase()
    ifg_instance_updated, epoch_list = \
        matlab_mst.get_nml(ifg_instance, nan_conversion=True)
    mst_grid = matlab_mst.matlab_mst_boolean_array(ifg_instance_updated)

    for i in ifgs:
        if not i.is_open:
            i.open()
        if not i.nan_converted:
            i.convert_to_nans()

        if not i.mm_converted:
            i.convert_to_mm()
            i.write_modified_phase()

    if params[cf.ORBITAL_FIT] != 0:
        run_pyrate.remove_orbital_error(ifgs, params)

    refx, refy = run_pyrate.find_reference_pixel(ifgs, params)

    if params[cf.ORBITAL_FIT] != 0:
        run_pyrate.remove_orbital_error(ifgs, params)

    _, ifgs = rpe.estimate_ref_phase(ifgs, params, refx, refy)

    # Calculate interferogram noise
    # TODO: assign maxvar to ifg metadata (and geotiff)?
    maxvar = [vcm.cvd(i)[0] for i in ifgs]

    # Calculate temporal variance-covariance matrix
    vcmt = vcm.get_vcmt(ifgs, maxvar)

    # Calculate linear rate map
    rate, error, samples = run_pyrate.calculate_linear_rate(ifgs, params, vcmt,
                                                 mst=mst_grid)

    print rate
    print error
    print samples
